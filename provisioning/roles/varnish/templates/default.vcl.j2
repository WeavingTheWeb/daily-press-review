vcl 4.0;


backend default {
    .host = "127.0.0.1";
    .port = "80";
}

backend devobs {
    .host = "127.0.0.1";
    .port = "8080";
}

backend devobs_nfs {
    .host = "127.0.0.1";
    .port = "8081";
}

// Acl's can contain IP's, subnets and hostnames
acl purge {
    "localhost";
}

sub vcl_recv {
    if (req.http.host ~ "devobs.dev") {
        set req.backend_hint = devobs;
    } elseif (req.http.host ~ "devobs-nfs.dev") {
        set req.backend_hint = devobs_nfs;
    }

    set req.http.Surrogate-Capability = "abc=ESI/1.0";

    if (req.http.Accept-Encoding) {
        if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)$") {
            # No point in compressing these
            unset req.http.Accept-Encoding;
        } elsif (req.http.Accept-Encoding ~ "gzip") {
            set req.http.Accept-Encoding = "gzip";
        } elsif (req.http.Accept-Encoding ~ "deflate" && req.http.user-agent !~ "MSIE") {
            set req.http.Accept-Encoding = "deflate";
        } else {
            # unkown algorithm
            unset req.http.Accept-Encoding;
        }
    }

    // Match PURGE request to avoid cache bypassing
    if (req.method == "PURGE") {
        // Match client IP to the acl
        if (!client.ip ~ purge) {
            // Deny access
            return (synth(405, "Not allowed."));
        }
        return(hash);
    }
}

sub vcl_backend_response {
    /*
    Check for ESI acknowledgement
    and remove Surrogate-Control header
    */
    if (beresp.http.Surrogate-Control ~ "ESI/1.0") {
        unset beresp.http.Surrogate-Control;

        // For Varnish >= 3.0
        set beresp.do_esi = true;
        // For Varnish < 3.0
        // esi;
    }
    /* By default Varnish ignores Cache-Control: nocache
    (https://www.varnish-cache.org/docs/3.0/tutorial/increasing_your_hitrate.html#cache-control),
    so in order avoid caching it has to be done explicitly */
    if (beresp.http.Pragma ~ "no-cache" ||
        beresp.http.Cache-Control ~ "no-cache" ||
        beresp.http.Cache-Control ~ "private") {
        set beresp.uncacheable = true;
        set beresp.ttl = 120s;
        return (deliver);
    }
}

# Below is a commented-out copy of the default VCL logic.  If you
# redefine any of these subroutines, the built-in logic will be
# appended to your code.
sub vcl_recv {
    if (req.restarts == 0) {
        if (req.http.x-forwarded-for) {
            set req.http.X-Forwarded-For =
            req.http.X-Forwarded-For + ", " + client.ip;
        } else {
            set req.http.X-Forwarded-For = client.ip;
        }
    }
    if (req.method != "GET" &&
      req.method != "HEAD" &&
      req.method != "PUT" &&
      req.method != "POST" &&
      req.method != "TRACE" &&
      req.method != "OPTIONS" &&
      req.method != "DELETE") {
        /* Non-RFC2616 or CONNECT which is weird. */
        return (pipe);
    }
    if (req.method != "GET" && req.method != "HEAD") {
        /* We only deal with GET and HEAD by default */
        return (pass);
    }

    if (req.http.Cookie) {
        set req.http.Cookie = ";" + req.http.Cookie;
        set req.http.Cookie = regsuball(req.http.Cookie, "; +", ";");
        set req.http.Cookie = regsuball(req.http.Cookie, ";(PHPSESSID)=", "; \1=");
        set req.http.Cookie = regsuball(req.http.Cookie, ";[^ ][^;]*", "");
        set req.http.Cookie = regsuball(req.http.Cookie, "^[; ]+|[; ]+$", "");

	set req.http.X-Cookie-Debug = "Request cookie: " + req.http.Cookie;

        if (req.http.Cookie == "") {
            unset req.http.Cookie;
        }
    }

    if (req.http.Authorization || req.http.Cookie) {
        /* Not cacheable by default */
        return (pass);
    }

    return (hash);
}

sub vcl_pass {
    set req.http.X-Forwarded-Port = "443";
    set req.http.X-Forwarded-Proto = "https";
    if (req.http.Authorization || req.http.Cookie) {
        return (fetch);
    }
}

sub vcl_hit {
    // Match PURGE request
    if (req.method == "PURGE") {
        // Force object expiration for Varnish < 3.0
        // set obj.ttl = 0s;
        // Do an actual purge for Varnish >= 3.0
        // purge;
        return (synth(200, "Purged"));
    }
}

sub vcl_miss {
    // Match PURGE request
    if (req.method == "PURGE") {
        // Indicate that the object isn't stored in cache
        return (synth(404, "Not purged"));
    }
}

